/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type wchar_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
pub type FILE = _iobuf;
pub type clock_t = ::std::os::raw::c_long;
pub type LCUI_BOOL = ::std::os::raw::c_uchar;
pub type uchar_t = ::std::os::raw::c_uchar;
impl LCUI_ColorType {
    #[doc = "< 8位索引"]
    pub const LCUI_COLOR_TYPE_INDEX8: LCUI_ColorType = LCUI_ColorType(0);
}
impl LCUI_ColorType {
    #[doc = "< 8位灰度"]
    pub const LCUI_COLOR_TYPE_GRAY8: LCUI_ColorType = LCUI_ColorType(1);
}
impl LCUI_ColorType {
    #[doc = "< RGB323"]
    pub const LCUI_COLOR_TYPE_RGB323: LCUI_ColorType = LCUI_ColorType(2);
}
impl LCUI_ColorType {
    #[doc = "< ARGB2222"]
    pub const LCUI_COLOR_TYPE_ARGB2222: LCUI_ColorType = LCUI_ColorType(3);
}
impl LCUI_ColorType {
    #[doc = "< RGB555"]
    pub const LCUI_COLOR_TYPE_RGB555: LCUI_ColorType = LCUI_ColorType(4);
}
impl LCUI_ColorType {
    #[doc = "< RGB565"]
    pub const LCUI_COLOR_TYPE_RGB565: LCUI_ColorType = LCUI_ColorType(5);
}
impl LCUI_ColorType {
    #[doc = "< RGB888"]
    pub const LCUI_COLOR_TYPE_RGB888: LCUI_ColorType = LCUI_ColorType(6);
}
impl LCUI_ColorType {
    #[doc = "< RGB8888"]
    pub const LCUI_COLOR_TYPE_ARGB8888: LCUI_ColorType = LCUI_ColorType(7);
}
#[repr(transparent)]
#[doc = " 色彩模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_ColorType(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_ARGB8888_ {
    pub value: i32,
    pub __bindgen_anon_1: LCUI_ARGB8888___bindgen_ty_1,
    pub __bindgen_anon_2: LCUI_ARGB8888___bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_ARGB8888___bindgen_ty_1 {
    pub b: uchar_t,
    pub g: uchar_t,
    pub r: uchar_t,
    pub a: uchar_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_ARGB8888___bindgen_ty_2 {
    pub blue: uchar_t,
    pub green: uchar_t,
    pub red: uchar_t,
    pub alpha: uchar_t,
}
pub type LCUI_ARGB = LCUI_ARGB8888_;
pub type LCUI_Color = LCUI_ARGB8888_;
#[doc = " Position in plane coordinate system"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_Pos_ {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[doc = " Position in plane coordinate system"]
pub type LCUI_Pos = LCUI_Pos_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_Rect_ {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
pub type LCUI_Rect = LCUI_Rect_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_RectF_ {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
pub type LCUI_RectF = LCUI_RectF_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_Rect2F_ {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
pub type LCUI_Rect2F = LCUI_Rect2F_;
impl LCUI_StyleValue {
    pub const SV_NONE: LCUI_StyleValue = LCUI_StyleValue(0);
}
impl LCUI_StyleValue {
    pub const SV_AUTO: LCUI_StyleValue = LCUI_StyleValue(1);
}
impl LCUI_StyleValue {
    pub const SV_NORMAL: LCUI_StyleValue = LCUI_StyleValue(2);
}
impl LCUI_StyleValue {
    pub const SV_INHERIT: LCUI_StyleValue = LCUI_StyleValue(3);
}
impl LCUI_StyleValue {
    pub const SV_INITIAL: LCUI_StyleValue = LCUI_StyleValue(4);
}
impl LCUI_StyleValue {
    pub const SV_CONTAIN: LCUI_StyleValue = LCUI_StyleValue(5);
}
impl LCUI_StyleValue {
    pub const SV_COVER: LCUI_StyleValue = LCUI_StyleValue(6);
}
impl LCUI_StyleValue {
    pub const SV_LEFT: LCUI_StyleValue = LCUI_StyleValue(7);
}
impl LCUI_StyleValue {
    pub const SV_CENTER: LCUI_StyleValue = LCUI_StyleValue(8);
}
impl LCUI_StyleValue {
    pub const SV_RIGHT: LCUI_StyleValue = LCUI_StyleValue(9);
}
impl LCUI_StyleValue {
    pub const SV_TOP: LCUI_StyleValue = LCUI_StyleValue(10);
}
impl LCUI_StyleValue {
    pub const SV_TOP_LEFT: LCUI_StyleValue = LCUI_StyleValue(11);
}
impl LCUI_StyleValue {
    pub const SV_TOP_CENTER: LCUI_StyleValue = LCUI_StyleValue(12);
}
impl LCUI_StyleValue {
    pub const SV_TOP_RIGHT: LCUI_StyleValue = LCUI_StyleValue(13);
}
impl LCUI_StyleValue {
    pub const SV_MIDDLE: LCUI_StyleValue = LCUI_StyleValue(14);
}
impl LCUI_StyleValue {
    pub const SV_CENTER_LEFT: LCUI_StyleValue = LCUI_StyleValue(15);
}
impl LCUI_StyleValue {
    pub const SV_CENTER_CENTER: LCUI_StyleValue = LCUI_StyleValue(16);
}
impl LCUI_StyleValue {
    pub const SV_CENTER_RIGHT: LCUI_StyleValue = LCUI_StyleValue(17);
}
impl LCUI_StyleValue {
    pub const SV_BOTTOM: LCUI_StyleValue = LCUI_StyleValue(18);
}
impl LCUI_StyleValue {
    pub const SV_BOTTOM_LEFT: LCUI_StyleValue = LCUI_StyleValue(19);
}
impl LCUI_StyleValue {
    pub const SV_BOTTOM_CENTER: LCUI_StyleValue = LCUI_StyleValue(20);
}
impl LCUI_StyleValue {
    pub const SV_BOTTOM_RIGHT: LCUI_StyleValue = LCUI_StyleValue(21);
}
impl LCUI_StyleValue {
    pub const SV_SOLID: LCUI_StyleValue = LCUI_StyleValue(22);
}
impl LCUI_StyleValue {
    pub const SV_DOTTED: LCUI_StyleValue = LCUI_StyleValue(23);
}
impl LCUI_StyleValue {
    pub const SV_DOUBLE: LCUI_StyleValue = LCUI_StyleValue(24);
}
impl LCUI_StyleValue {
    pub const SV_DASHED: LCUI_StyleValue = LCUI_StyleValue(25);
}
impl LCUI_StyleValue {
    pub const SV_CONTENT_BOX: LCUI_StyleValue = LCUI_StyleValue(26);
}
impl LCUI_StyleValue {
    pub const SV_PADDING_BOX: LCUI_StyleValue = LCUI_StyleValue(27);
}
impl LCUI_StyleValue {
    pub const SV_BORDER_BOX: LCUI_StyleValue = LCUI_StyleValue(28);
}
impl LCUI_StyleValue {
    pub const SV_GRAPH_BOX: LCUI_StyleValue = LCUI_StyleValue(29);
}
impl LCUI_StyleValue {
    pub const SV_STATIC: LCUI_StyleValue = LCUI_StyleValue(30);
}
impl LCUI_StyleValue {
    pub const SV_RELATIVE: LCUI_StyleValue = LCUI_StyleValue(31);
}
impl LCUI_StyleValue {
    pub const SV_ABSOLUTE: LCUI_StyleValue = LCUI_StyleValue(32);
}
impl LCUI_StyleValue {
    pub const SV_BLOCK: LCUI_StyleValue = LCUI_StyleValue(33);
}
impl LCUI_StyleValue {
    pub const SV_INLINE_BLOCK: LCUI_StyleValue = LCUI_StyleValue(34);
}
impl LCUI_StyleValue {
    pub const SV_FLEX: LCUI_StyleValue = LCUI_StyleValue(35);
}
impl LCUI_StyleValue {
    pub const SV_FLEX_START: LCUI_StyleValue = LCUI_StyleValue(36);
}
impl LCUI_StyleValue {
    pub const SV_FLEX_END: LCUI_StyleValue = LCUI_StyleValue(37);
}
impl LCUI_StyleValue {
    pub const SV_STRETCH: LCUI_StyleValue = LCUI_StyleValue(38);
}
impl LCUI_StyleValue {
    pub const SV_SPACE_BETWEEN: LCUI_StyleValue = LCUI_StyleValue(39);
}
impl LCUI_StyleValue {
    pub const SV_SPACE_AROUND: LCUI_StyleValue = LCUI_StyleValue(40);
}
impl LCUI_StyleValue {
    pub const SV_SPACE_EVENLY: LCUI_StyleValue = LCUI_StyleValue(41);
}
impl LCUI_StyleValue {
    pub const SV_WRAP: LCUI_StyleValue = LCUI_StyleValue(42);
}
impl LCUI_StyleValue {
    pub const SV_NOWRAP: LCUI_StyleValue = LCUI_StyleValue(43);
}
impl LCUI_StyleValue {
    pub const SV_ROW: LCUI_StyleValue = LCUI_StyleValue(44);
}
impl LCUI_StyleValue {
    pub const SV_COLUMN: LCUI_StyleValue = LCUI_StyleValue(45);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_StyleValue(pub ::std::os::raw::c_int);
impl LCUI_StyleType {
    pub const LCUI_STYPE_NONE: LCUI_StyleType = LCUI_StyleType(0);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_AUTO: LCUI_StyleType = LCUI_StyleType(1);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_SCALE: LCUI_StyleType = LCUI_StyleType(2);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_PX: LCUI_StyleType = LCUI_StyleType(3);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_PT: LCUI_StyleType = LCUI_StyleType(4);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_DIP: LCUI_StyleType = LCUI_StyleType(5);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_SP: LCUI_StyleType = LCUI_StyleType(6);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_COLOR: LCUI_StyleType = LCUI_StyleType(7);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_IMAGE: LCUI_StyleType = LCUI_StyleType(8);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_STYLE: LCUI_StyleType = LCUI_StyleType(9);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_INT: LCUI_StyleType = LCUI_StyleType(10);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_BOOL: LCUI_StyleType = LCUI_StyleType(11);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_STRING: LCUI_StyleType = LCUI_StyleType(12);
}
impl LCUI_StyleType {
    pub const LCUI_STYPE_WSTRING: LCUI_StyleType = LCUI_StyleType(13);
}
#[repr(transparent)]
#[doc = " 样式变量类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_StyleType(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BoxShadowStyle {
    pub x: f32,
    pub y: f32,
    pub blur: f32,
    pub spread: f32,
    pub color: LCUI_Color,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BoxShadow {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub blur: ::std::os::raw::c_int,
    pub spread: ::std::os::raw::c_int,
    pub color: LCUI_Color,
    pub top_left_radius: ::std::os::raw::c_int,
    pub top_right_radius: ::std::os::raw::c_int,
    pub bottom_left_radius: ::std::os::raw::c_int,
    pub bottom_right_radius: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BorderStyle {
    pub top: LCUI_BorderStyle__bindgen_ty_1,
    pub right: LCUI_BorderStyle__bindgen_ty_1,
    pub bottom: LCUI_BorderStyle__bindgen_ty_1,
    pub left: LCUI_BorderStyle__bindgen_ty_1,
    pub top_left_radius: f32,
    pub top_right_radius: f32,
    pub bottom_left_radius: f32,
    pub bottom_right_radius: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BorderStyle__bindgen_ty_1 {
    pub style: ::std::os::raw::c_int,
    pub width: f32,
    pub color: LCUI_Color,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BorderLine {
    pub style: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_uint,
    pub color: LCUI_Color,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_Border {
    pub top: LCUI_BorderLine,
    pub right: LCUI_BorderLine,
    pub bottom: LCUI_BorderLine,
    pub left: LCUI_BorderLine,
    pub top_left_radius: ::std::os::raw::c_uint,
    pub top_right_radius: ::std::os::raw::c_uint,
    pub bottom_left_radius: ::std::os::raw::c_uint,
    pub bottom_right_radius: ::std::os::raw::c_uint,
}
pub type LCUI_Graph = LCUI_Graph_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_GraphQuote_ {
    pub top: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub is_valid: LCUI_BOOL,
    pub is_writable: LCUI_BOOL,
    pub __bindgen_anon_1: LCUI_GraphQuote___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_GraphQuote___bindgen_ty_1 {
    pub source: *mut LCUI_Graph,
    pub source_ro: *const LCUI_Graph,
}
pub type LCUI_GraphQuote = LCUI_GraphQuote_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_Graph_ {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub quote: LCUI_GraphQuote,
    pub __bindgen_anon_1: LCUI_Graph___bindgen_ty_1,
    pub color_type: LCUI_ColorType,
    pub bytes_per_pixel: ::std::os::raw::c_uint,
    pub bytes_per_row: ::std::os::raw::c_uint,
    pub opacity: f32,
    pub mem_size: usize,
    pub palette: *mut uchar_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_Graph___bindgen_ty_1 {
    pub bytes: *mut uchar_t,
    pub argb: *mut LCUI_ARGB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_StyleRec_ {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_1: LCUI_StyleRec___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_StyleRec___bindgen_ty_1 {
    pub val_int: ::std::os::raw::c_int,
    pub val_0: ::std::os::raw::c_int,
    pub val_none: ::std::os::raw::c_int,
    pub value: f32,
    pub px: f32,
    pub val_px: f32,
    pub pt: f32,
    pub val_pt: f32,
    pub dp: f32,
    pub val_dp: f32,
    pub dip: f32,
    pub val_dip: f32,
    pub sp: f32,
    pub val_sp: f32,
    pub style: LCUI_StyleValue,
    pub val_style: LCUI_StyleValue,
    pub scale: f32,
    pub val_scale: f32,
    pub string: *mut ::std::os::raw::c_char,
    pub val_string: *mut ::std::os::raw::c_char,
    pub wstring: *mut wchar_t,
    pub val_wstring: *mut wchar_t,
    pub color: LCUI_Color,
    pub val_color: LCUI_Color,
    pub image: *mut LCUI_Graph,
    pub val_image: *mut LCUI_Graph,
    pub val_bool: LCUI_BOOL,
}
impl LCUI_StyleRec_ {
    #[inline]
    pub fn is_valid(&self) -> LCUI_BOOL {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_is_valid(&mut self, val: LCUI_BOOL) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> LCUI_StyleType {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: LCUI_StyleType) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_valid: LCUI_BOOL,
        type_: LCUI_StyleType,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let is_valid: u8 = unsafe { ::std::mem::transmute(is_valid) };
            is_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type LCUI_StyleRec = LCUI_StyleRec_;
pub type LCUI_Style = *mut LCUI_StyleRec_;
impl LCUI_SizingRule_ {
    pub const LCUI_SIZING_RULE_NONE: LCUI_SizingRule_ = LCUI_SizingRule_(0);
}
impl LCUI_SizingRule_ {
    pub const LCUI_SIZING_RULE_FIXED: LCUI_SizingRule_ = LCUI_SizingRule_(1);
}
impl LCUI_SizingRule_ {
    pub const LCUI_SIZING_RULE_FILL: LCUI_SizingRule_ = LCUI_SizingRule_(2);
}
impl LCUI_SizingRule_ {
    pub const LCUI_SIZING_RULE_PERCENT: LCUI_SizingRule_ = LCUI_SizingRule_(3);
}
impl LCUI_SizingRule_ {
    pub const LCUI_SIZING_RULE_FIT_CONTENT: LCUI_SizingRule_ = LCUI_SizingRule_(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_SizingRule_(pub ::std::os::raw::c_int);
pub use self::LCUI_SizingRule_ as LCUI_SizingRule;
impl LCUI_LayoutRule_ {
    pub const LCUI_LAYOUT_RULE_AUTO: LCUI_LayoutRule_ = LCUI_LayoutRule_(0);
}
impl LCUI_LayoutRule_ {
    pub const LCUI_LAYOUT_RULE_MAX_CONTENT: LCUI_LayoutRule_ = LCUI_LayoutRule_(1);
}
impl LCUI_LayoutRule_ {
    pub const LCUI_LAYOUT_RULE_FIXED_WIDTH: LCUI_LayoutRule_ = LCUI_LayoutRule_(2);
}
impl LCUI_LayoutRule_ {
    pub const LCUI_LAYOUT_RULE_FIXED_HEIGHT: LCUI_LayoutRule_ = LCUI_LayoutRule_(3);
}
impl LCUI_LayoutRule_ {
    pub const LCUI_LAYOUT_RULE_FIXED: LCUI_LayoutRule_ = LCUI_LayoutRule_(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_LayoutRule_(pub ::std::os::raw::c_int);
pub use self::LCUI_LayoutRule_ as LCUI_LayoutRule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_FlexLayoutStyle {
    #[doc = " The flex shrink factor of a flex item\n See more:\n https://developer.mozilla.org/en-US/docs/Web/CSS/flex-shrink"]
    pub shrink: f32,
    pub grow: f32,
    #[doc = " The initial main size of a flex item\n See more: https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis"]
    pub basis: f32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl LCUI_FlexLayoutStyle {
    #[inline]
    pub fn wrap(&self) -> LCUI_StyleValue {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrap(&mut self, val: LCUI_StyleValue) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn direction(&self) -> LCUI_StyleValue {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: LCUI_StyleValue) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn align_items(&self) -> LCUI_StyleValue {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_align_items(&mut self, val: LCUI_StyleValue) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn align_content(&self) -> LCUI_StyleValue {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_align_content(&mut self, val: LCUI_StyleValue) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn justify_content(&self) -> LCUI_StyleValue {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_justify_content(&mut self, val: LCUI_StyleValue) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wrap: LCUI_StyleValue,
        direction: LCUI_StyleValue,
        align_items: LCUI_StyleValue,
        align_content: LCUI_StyleValue,
        justify_content: LCUI_StyleValue,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let wrap: u32 = unsafe { ::std::mem::transmute(wrap) };
            wrap as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let direction: u32 = unsafe { ::std::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let align_items: u32 = unsafe { ::std::mem::transmute(align_items) };
            align_items as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let align_content: u32 = unsafe { ::std::mem::transmute(align_content) };
            align_content as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let justify_content: u32 = unsafe { ::std::mem::transmute(justify_content) };
            justify_content as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type LCUI_FlexBoxLayoutStyle = LCUI_FlexLayoutStyle;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BackgroundPosition {
    pub using_value: LCUI_BOOL,
    pub __bindgen_anon_1: LCUI_BackgroundPosition__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_BackgroundPosition__bindgen_ty_1 {
    pub __bindgen_anon_1: LCUI_BackgroundPosition__bindgen_ty_1__bindgen_ty_1,
    pub value: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BackgroundPosition__bindgen_ty_1__bindgen_ty_1 {
    pub x: LCUI_StyleRec,
    pub y: LCUI_StyleRec,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BackgroundSize {
    pub using_value: LCUI_BOOL,
    pub __bindgen_anon_1: LCUI_BackgroundSize__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_BackgroundSize__bindgen_ty_1 {
    pub __bindgen_anon_1: LCUI_BackgroundSize__bindgen_ty_1__bindgen_ty_1,
    pub value: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BackgroundSize__bindgen_ty_1__bindgen_ty_1 {
    pub width: LCUI_StyleRec,
    pub height: LCUI_StyleRec,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_BackgroundStyle {
    #[doc = "< 背景图"]
    pub image: LCUI_Graph,
    #[doc = "< 背景色"]
    pub color: LCUI_Color,
    #[doc = "< 背景图是否重复"]
    pub repeat: LCUI_BackgroundStyle__bindgen_ty_1,
    #[doc = "< 定位方式"]
    pub position: LCUI_BackgroundPosition,
    #[doc = "< 尺寸"]
    pub size: LCUI_BackgroundSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_BackgroundStyle__bindgen_ty_1 {
    pub x: LCUI_BOOL,
    pub y: LCUI_BOOL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_Background {
    #[doc = "< 背景图"]
    pub image: *mut LCUI_Graph,
    #[doc = "< 背景色"]
    pub color: LCUI_Color,
    #[doc = "< 背景图是否重复"]
    pub repeat: LCUI_Background__bindgen_ty_1,
    pub position: LCUI_Background__bindgen_ty_2,
    pub size: LCUI_Background__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_Background__bindgen_ty_1 {
    pub x: LCUI_BOOL,
    pub y: LCUI_BOOL,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_Background__bindgen_ty_2 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_Background__bindgen_ty_3 {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[doc = " 进行绘制时所需的上下文"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_PaintContextRec_ {
    #[doc = "< 需要绘制的区域"]
    pub rect: LCUI_Rect,
    #[doc = "< 绘制后的位图缓存（可称为：画布）"]
    pub canvas: LCUI_Graph,
    #[doc = "< 绘制时是否需要处理 alpha 通道"]
    pub with_alpha: LCUI_BOOL,
}
#[doc = " 进行绘制时所需的上下文"]
pub type LCUI_PaintContext = *mut LCUI_PaintContextRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_WidgetTasksRec_ {
    pub time: clock_t,
    pub update_count: usize,
    pub refresh_count: usize,
    pub layout_count: usize,
    pub user_task_count: usize,
    pub destroy_count: usize,
    pub destroy_time: usize,
}
pub type LCUI_WidgetTasksProfileRec = LCUI_WidgetTasksRec_;
pub type LCUI_WidgetTasksProfile = *mut LCUI_WidgetTasksRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_FrameProfileRec_ {
    pub timers_count: usize,
    pub timers_time: clock_t,
    pub events_count: usize,
    pub events_time: clock_t,
    pub render_count: usize,
    pub render_time: clock_t,
    pub present_time: clock_t,
    pub widget_tasks: LCUI_WidgetTasksProfileRec,
}
pub type LCUI_FrameProfile = *mut LCUI_FrameProfileRec_;
extern "C" {
    pub fn LCUITime_Init();
}
extern "C" {
    pub fn LCUI_GetTime() -> i64;
}
extern "C" {
    pub fn LCUI_GetTimeDelta(start: i64) -> i64;
}
extern "C" {
    pub fn LCUI_Sleep(s: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn LCUI_MSleep(ms: ::std::os::raw::c_uint);
}
pub type DWORD = ::std::os::raw::c_ulong;
pub type CHAR = ::std::os::raw::c_char;
pub type WCHAR = wchar_t;
pub type HANDLE = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
pub type FILETIME = _FILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_FIND_DATAA {
    pub dwFileAttributes: DWORD,
    pub ftCreationTime: FILETIME,
    pub ftLastAccessTime: FILETIME,
    pub ftLastWriteTime: FILETIME,
    pub nFileSizeHigh: DWORD,
    pub nFileSizeLow: DWORD,
    pub dwReserved0: DWORD,
    pub dwReserved1: DWORD,
    pub cFileName: [CHAR; 260usize],
    pub cAlternateFileName: [CHAR; 14usize],
}
pub type WIN32_FIND_DATAA = _WIN32_FIND_DATAA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_FIND_DATAW {
    pub dwFileAttributes: DWORD,
    pub ftCreationTime: FILETIME,
    pub ftLastAccessTime: FILETIME,
    pub ftLastWriteTime: FILETIME,
    pub nFileSizeHigh: DWORD,
    pub nFileSizeLow: DWORD,
    pub dwReserved0: DWORD,
    pub dwReserved1: DWORD,
    pub cFileName: [WCHAR; 260usize],
    pub cAlternateFileName: [WCHAR; 14usize],
}
pub type WIN32_FIND_DATAW = _WIN32_FIND_DATAW;
pub type LCUI_DirHandle = HANDLE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_DirEntry_ {
    pub dataA: WIN32_FIND_DATAA,
    pub dataW: WIN32_FIND_DATAW,
}
pub type LCUI_DirEntry = LCUI_DirEntry_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_Dir_ {
    pub handle: LCUI_DirHandle,
    pub entry: LCUI_DirEntry,
    pub cached: ::std::os::raw::c_int,
}
pub type LCUI_Dir = LCUI_Dir_;
extern "C" {
    pub fn LCUI_OpenDirW(filepath: *const wchar_t, dir: *mut LCUI_Dir) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_OpenDirA(
        filepath: *const ::std::os::raw::c_char,
        dir: *mut LCUI_Dir,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ReadDirA(dir: *mut LCUI_Dir) -> *mut LCUI_DirEntry;
}
extern "C" {
    pub fn LCUI_ReadDirW(dir: *mut LCUI_Dir) -> *mut LCUI_DirEntry;
}
extern "C" {
    pub fn LCUI_CloseDir(dir: *mut LCUI_Dir) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_GetFileNameA(entry: *mut LCUI_DirEntry) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LCUI_GetFileNameW(entry: *mut LCUI_DirEntry) -> *mut wchar_t;
}
extern "C" {
    pub fn LCUI_FileIsDirectory(entry: *mut LCUI_DirEntry) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_FileIsRegular(entry: *mut LCUI_DirEntry) -> ::std::os::raw::c_int;
}
pub type RBTreeNode = RBTreeNodeRec_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RBTreeNodeRec_ {
    pub color: ::std::os::raw::c_uchar,
    pub key: ::std::os::raw::c_int,
    pub __bindgen_anon_1: RBTreeNodeRec___bindgen_ty_1,
    pub parent: *mut RBTreeNode,
    pub left: *mut RBTreeNode,
    pub right: *mut RBTreeNode,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RBTreeNodeRec___bindgen_ty_1 {
    pub data: *mut ::std::os::raw::c_void,
    pub str_: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBTreeRec_ {
    pub total_node: ::std::os::raw::c_int,
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub root: *mut RBTreeNode,
}
pub type RBTree = RBTreeRec_;
pub type LinkedListNode = LinkedListNodeRec_;
pub type LinkedList = LinkedListRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedListNodeRec_ {
    pub data: *mut ::std::os::raw::c_void,
    pub prev: *mut LinkedListNode,
    pub next: *mut LinkedListNode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedListRec_ {
    pub length: usize,
    pub head: LinkedListNode,
    pub tail: LinkedListNode,
}
#[doc = " 哈希表节点结构"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DictEntry {
    pub key: *mut ::std::os::raw::c_void,
    pub v: DictEntry__bindgen_ty_1,
    #[doc = "< 指向下一个哈希节点(形成链表)"]
    pub next: *mut DictEntry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DictEntry__bindgen_ty_1 {
    pub val: *mut ::std::os::raw::c_void,
    pub u64_: u64,
    pub s64: i64,
}
#[doc = " 字典内数据的类型"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DictType {
    pub hashFunction: ::std::option::Option<
        unsafe extern "C" fn(key: *const ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
    >,
    pub keyDup: ::std::option::Option<
        unsafe extern "C" fn(
            privdata: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub valDup: ::std::option::Option<
        unsafe extern "C" fn(
            privdata: *mut ::std::os::raw::c_void,
            obj: *const ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub keyCompare: ::std::option::Option<
        unsafe extern "C" fn(
            privdata: *mut ::std::os::raw::c_void,
            key1: *const ::std::os::raw::c_void,
            key2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub keyDestructor: ::std::option::Option<
        unsafe extern "C" fn(
            privdata: *mut ::std::os::raw::c_void,
            key: *mut ::std::os::raw::c_void,
        ),
    >,
    pub valDestructor: ::std::option::Option<
        unsafe extern "C" fn(
            privdata: *mut ::std::os::raw::c_void,
            obj: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[doc = " 哈希表结构"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DictHashTable {
    #[doc = "< 节点指针数组"]
    pub table: *mut *mut DictEntry,
    #[doc = "< 桶的数量"]
    pub size: ::std::os::raw::c_ulong,
    #[doc = "< mask 码，用于地址索引计算"]
    pub sizemask: ::std::os::raw::c_ulong,
    #[doc = "< 已有节点数量"]
    pub used: ::std::os::raw::c_ulong,
}
#[doc = " 字典结构"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dict {
    #[doc = "< 为哈希表中不同类型的值所使用的一族函数"]
    pub type_: *mut DictType,
    pub privdata: *mut ::std::os::raw::c_void,
    #[doc = "< 每个字典使用两个哈希表"]
    pub ht: [DictHashTable; 2usize],
    #[doc = "< rehash 进行到的索引位置，如果没有在 rehash ，就为 -1"]
    pub rehashidx: ::std::os::raw::c_int,
    #[doc = "< 当前正在使用的 iterator 的数量"]
    pub iterators: ::std::os::raw::c_int,
}
pub type LCUI_ObjectTypeRec = LCUI_ObjectTypeRec_;
pub type LCUI_Object = *mut LCUI_ObjectRec_;
pub type LCUI_ObjectRec = LCUI_ObjectRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_ObjectTypeRec_ {
    pub hash: ::std::os::raw::c_uint,
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Object)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Object)>,
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(arg1: LCUI_Object, arg2: LCUI_Object) -> ::std::os::raw::c_int,
    >,
    pub opreate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: LCUI_Object,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const LCUI_ObjectRec,
        ) -> LCUI_Object,
    >,
    pub duplicate:
        ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Object, arg2: *const LCUI_ObjectRec)>,
    pub tostring: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Object, arg2: LCUI_Object)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_ObjectRec_ {
    pub type_: *const LCUI_ObjectTypeRec,
    pub value: LCUI_ObjectRec__LCUI_ObjectValueUnion,
    pub size: usize,
    pub watchers: *mut LinkedList,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_ObjectRec__LCUI_ObjectValueUnion {
    pub number: f64,
    pub string: *mut ::std::os::raw::c_char,
    pub wstring: *mut wchar_t,
    pub data: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = " 根据容器尺寸，获取指定区域中需要裁剪的区域"]
    pub fn LCUIRect_GetCutArea(
        box_w: ::std::os::raw::c_int,
        box_h: ::std::os::raw::c_int,
        rect: LCUI_Rect,
        cut: *mut LCUI_Rect,
    );
}
extern "C" {
    #[doc = " 将矩形区域范围调整在容器有效范围内"]
    pub fn LCUIRect_ValidateArea(
        rect: *mut LCUI_Rect,
        box_w: ::std::os::raw::c_int,
        box_h: ::std::os::raw::c_int,
    ) -> LCUI_BOOL;
}
extern "C" {
    pub fn LCUIRectF_ValidateArea(rect: *mut LCUI_RectF, box_w: f32, box_h: f32) -> LCUI_BOOL;
}
extern "C" {
    pub fn LCUIRect_ToRectF(rect: *const LCUI_Rect, rectf: *mut LCUI_RectF, scale: f32);
}
extern "C" {
    pub fn LCUIRect_Scale(src: *const LCUI_Rect, dst: *mut LCUI_Rect, scale: f32);
}
extern "C" {
    pub fn LCUIRectF_ToRect(rectf: *const LCUI_RectF, rect: *mut LCUI_Rect, scale: f32);
}
extern "C" {
    #[doc = " 检测矩形是否遮盖另一个矩形"]
    pub fn LCUIRect_IsCoverRect(a: *const LCUI_Rect, b: *const LCUI_Rect) -> LCUI_BOOL;
}
extern "C" {
    pub fn LCUIRectF_IsCoverRect(a: *const LCUI_RectF, b: *const LCUI_RectF) -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 获取两个矩形中的重叠矩形\n @param[in] a\t\t矩形A\n @param[in] b\t\t矩形B\n @param[out] out\t矩形A和B重叠处的矩形\n @returns 如果两个矩形重叠，则返回TRUE，否则返回FALSE"]
    pub fn LCUIRect_GetOverlayRect(
        a: *const LCUI_Rect,
        b: *const LCUI_Rect,
        out: *mut LCUI_Rect,
    ) -> LCUI_BOOL;
}
extern "C" {
    pub fn LCUIRectF_GetOverlayRect(
        a: *const LCUI_RectF,
        b: *const LCUI_RectF,
        out: *mut LCUI_RectF,
    ) -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 合并两个矩形"]
    pub fn LCUIRect_MergeRect(big: *mut LCUI_Rect, a: *const LCUI_Rect, b: *const LCUI_Rect);
}
extern "C" {
    pub fn LCUIRectF_MergeRect(big: *mut LCUI_RectF, a: *const LCUI_RectF, b: *const LCUI_RectF);
}
extern "C" {
    #[doc = " 根据重叠矩形 rect1，将矩形 rect2 分割成四个矩形\n 分割方法如下：\n ┏━━┳━━━━━━┓\n ┃    ┃     3      ┃\n ┃ 0  ┣━━━┳━━┃\n ┃    ┃rect1 ┃    ┃\n ┃    ┃      ┃ 2  ┃\n ┣━━┻━━━┫    ┃\n ┃     1      ┃    ┃\n ┗━━━━━━┻━━┛\n\n rect2 必须被 rect1 完全包含"]
    pub fn LCUIRect_CutFourRect(
        rect1: *mut LCUI_Rect,
        rect2: *mut LCUI_Rect,
        rects: *mut LCUI_Rect,
    );
}
extern "C" {
    pub fn LCUIRect_Split(base: *mut LCUI_Rect, target: *mut LCUI_Rect, rects: *mut LCUI_Rect);
}
pub type strlist_t = *mut *mut ::std::os::raw::c_char;
#[doc = " 事件数据结构"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_EventRec_ {
    #[doc = "< 事件类型"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< 事件附加数据"]
    pub data: *mut ::std::os::raw::c_void,
}
#[doc = " 事件数据结构"]
pub type LCUI_Event = *mut LCUI_EventRec_;
pub type LCUI_EventFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: LCUI_Event, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_EventTriggerRec_ {
    #[doc = "< 事件处理器ID"]
    pub handler_base_id: ::std::os::raw::c_int,
    #[doc = "< 事件绑定记录"]
    pub events: RBTree,
    #[doc = "< 事件处理器记录"]
    pub handlers: RBTree,
}
pub type LCUI_EventTrigger = *mut LCUI_EventTriggerRec_;
pub type LCUI_TaskFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_TaskRec_ {
    #[doc = "< 任务处理函数"]
    pub func: LCUI_TaskFunc,
    #[doc = "< 两个参数"]
    pub arg: [*mut ::std::os::raw::c_void; 2usize],
    #[doc = "< 参数的销毁函数"]
    pub destroy_arg:
        [::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>; 2usize],
}
pub type LCUI_Task = *mut LCUI_TaskRec_;
extern "C" {
    pub fn LCUITask_Destroy(task: LCUI_Task);
}
extern "C" {
    pub fn LCUITask_Run(task: LCUI_Task) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_DecodeString(
        wstr: *mut wchar_t,
        str_: *const ::std::os::raw::c_char,
        max_len: usize,
        encoding: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn LCUI_EncodeString(
        str_: *mut ::std::os::raw::c_char,
        wstr: *const wchar_t,
        max_len: usize,
        encoding: ::std::os::raw::c_int,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_TouchPointRec_ {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub id: ::std::os::raw::c_int,
    pub state: ::std::os::raw::c_int,
    pub is_primary: LCUI_BOOL,
}
pub type LCUI_TouchPoint = *mut LCUI_TouchPointRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_PaintEvent_ {
    pub rect: LCUI_Rect,
}
pub type LCUI_PaintEvent = LCUI_PaintEvent_;
#[doc = " The event structure to describe a user interaction with the keyboard"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_KeyboardEvent_ {
    #[doc = " The virtual-key code of the nonsystem key"]
    pub code: ::std::os::raw::c_int,
    #[doc = " whether the Ctrl key was active when the key event was generated"]
    pub ctrl_key: LCUI_BOOL,
    #[doc = " whether the Shift key was active when the key event was generated"]
    pub shift_key: LCUI_BOOL,
}
#[doc = " The event structure to describe a user interaction with the keyboard"]
pub type LCUI_KeyboardEvent = LCUI_KeyboardEvent_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_MouseMotionEvent_ {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub xrel: ::std::os::raw::c_int,
    pub yrel: ::std::os::raw::c_int,
}
pub type LCUI_MouseMotionEvent = LCUI_MouseMotionEvent_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_MouseButtonEvent_ {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub button: ::std::os::raw::c_int,
}
pub type LCUI_MouseButtonEvent = LCUI_MouseButtonEvent_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_MouseWheelEvent_ {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub delta: ::std::os::raw::c_int,
}
pub type LCUI_MouseWheelEvent = LCUI_MouseWheelEvent_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_TouchEvent_ {
    pub n_points: ::std::os::raw::c_int,
    pub points: LCUI_TouchPoint,
}
pub type LCUI_TouchEvent = LCUI_TouchEvent_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_TextInputEvent_ {
    pub text: *mut wchar_t,
    pub length: usize,
}
pub type LCUI_TextInputEvent = LCUI_TextInputEvent_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_SysEventRec_ {
    pub type_: u32,
    pub data: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: LCUI_SysEventRec___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_SysEventRec___bindgen_ty_1 {
    pub motion: LCUI_MouseMotionEvent,
    pub button: LCUI_MouseButtonEvent,
    pub wheel: LCUI_MouseWheelEvent,
    pub text: LCUI_TextInputEvent,
    pub key: LCUI_KeyboardEvent,
    pub touch: LCUI_TouchEvent,
    pub paint: LCUI_PaintEvent,
}
pub type LCUI_SysEvent = *mut LCUI_SysEventRec_;
pub type LCUI_SysEventFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: LCUI_SysEvent, arg2: *mut ::std::os::raw::c_void),
>;
impl LCUI_AppDriverId_ {
    pub const LCUI_APP_UNKNOWN: LCUI_AppDriverId_ = LCUI_AppDriverId_(0);
}
impl LCUI_AppDriverId_ {
    pub const LCUI_APP_LINUX: LCUI_AppDriverId_ = LCUI_AppDriverId_(1);
}
impl LCUI_AppDriverId_ {
    pub const LCUI_APP_LINUX_X11: LCUI_AppDriverId_ = LCUI_AppDriverId_(2);
}
impl LCUI_AppDriverId_ {
    pub const LCUI_APP_WINDOWS: LCUI_AppDriverId_ = LCUI_AppDriverId_(3);
}
impl LCUI_AppDriverId_ {
    pub const LCUI_APP_UWP: LCUI_AppDriverId_ = LCUI_AppDriverId_(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_AppDriverId_(pub ::std::os::raw::c_int);
pub use self::LCUI_AppDriverId_ as LCUI_AppDriverId;
#[doc = " LCUI 应用程序驱动接口，封装了各个平台下的应用程序相关功能支持接口"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_AppDriverRec_ {
    pub id: LCUI_AppDriverId,
    pub ProcessEvents: ::std::option::Option<unsafe extern "C" fn()>,
    pub BindSysEvent: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: LCUI_EventFunc,
            arg3: *mut ::std::os::raw::c_void,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
    pub UnbindSysEvent: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: LCUI_EventFunc,
        ) -> ::std::os::raw::c_int,
    >,
    pub UnbindSysEvent2: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub GetData: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
}
#[doc = " LCUI 应用程序驱动接口，封装了各个平台下的应用程序相关功能支持接口"]
pub type LCUI_AppDriver = *mut LCUI_AppDriverRec_;
pub type LCUI_MainLoop = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn LCUI_BindEvent(
        id: ::std::os::raw::c_int,
        func: LCUI_SysEventFunc,
        data: *mut ::std::os::raw::c_void,
        destroy_data: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_UnbindEvent(handler_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_TriggerEvent(
        e: LCUI_SysEvent,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_CreateTouchEvent(
        e: LCUI_SysEvent,
        points: LCUI_TouchPoint,
        n_points: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_DestroyEvent(e: LCUI_SysEvent);
}
extern "C" {
    pub fn LCUI_BindSysEvent(
        event_id: ::std::os::raw::c_int,
        func: LCUI_EventFunc,
        data: *mut ::std::os::raw::c_void,
        destroy_data: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_UnbindSysEvent(
        event_id: ::std::os::raw::c_int,
        func: LCUI_EventFunc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_GetAppData() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LCUI_GetAppId() -> LCUI_AppDriverId;
}
extern "C" {
    #[doc = " 处理当前所有事件"]
    pub fn LCUI_ProcessEvents() -> usize;
}
extern "C" {
    #[doc = " 添加任务\n 该任务将会添加至主线程中执行"]
    pub fn LCUI_PostTask(task: LCUI_Task) -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 添加异步任务\n 该任务将会添加至指定 id 的工作线程中执行\n @param[in] task 任务数据\n @param[in] target_worker_id 目标工作线程的编号"]
    pub fn LCUI_PostAsyncTaskTo(task: LCUI_Task, target_worker_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " 添加异步任务\n 该任务将会添加至工作线程中执行"]
    pub fn LCUI_PostAsyncTask(task: LCUI_Task) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_RunFrame();
}
extern "C" {
    pub fn LCUI_RunFrameWithProfile(profile: LCUI_FrameProfile);
}
extern "C" {
    pub fn LCUIMainLoop_New() -> LCUI_MainLoop;
}
extern "C" {
    pub fn LCUIMainLoop_Run(loop_: LCUI_MainLoop) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIMainLoop_Quit(loop_: LCUI_MainLoop);
}
extern "C" {
    pub fn LCUIMainLoop_Destroy(loop_: LCUI_MainLoop);
}
extern "C" {
    pub fn LCUI_IsActive() -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 获取当前帧数"]
    pub fn LCUI_GetFrameCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_InitBase();
}
extern "C" {
    pub fn LCUI_InitApp(app: LCUI_AppDriver);
}
extern "C" {
    #[doc = " 初始化 LCUI 各项功能"]
    pub fn LCUI_Init();
}
extern "C" {
    #[doc = " 进入 LCUI 主循环\n 调用该函数后，LCUI 会将当前线程作为 UI 线程，用于处理部件更新、布局、渲染等\n 与图形界面相关的任务。"]
    pub fn LCUI_Main() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 获取LCUI的版本"]
    pub fn LCUI_GetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " 释放LCUI占用的资源"]
    pub fn LCUI_Destroy() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 退出LCUI，释放LCUI占用的资源"]
    pub fn LCUI_Quit();
}
extern "C" {
    #[doc = " 退出 LCUI，并设置退出码"]
    pub fn LCUI_Exit(code: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " 检测当前是否在主线程上"]
    pub fn LCUI_IsOnMainLoop() -> LCUI_BOOL;
}
extern "C" {
    pub fn LCUI_InitCursor();
}
extern "C" {
    pub fn LCUI_FreeCursor();
}
extern "C" {
    pub fn LCUICursor_GetRect(rect: *mut LCUI_Rect);
}
extern "C" {
    pub fn LCUICursor_Refresh();
}
extern "C" {
    pub fn LCUICursor_IsVisible() -> LCUI_BOOL;
}
extern "C" {
    pub fn LCUICursor_Show();
}
extern "C" {
    pub fn LCUICursor_Hide();
}
extern "C" {
    pub fn LCUICursor_Update();
}
extern "C" {
    pub fn LCUICursor_SetPos(pos: LCUI_Pos);
}
extern "C" {
    #[doc = " 设置游标的图形"]
    pub fn LCUICursor_SetGraph(graph: *mut LCUI_Graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUICursor_GetPos(pos: *mut LCUI_Pos);
}
extern "C" {
    pub fn LCUICursor_Paint(paint: LCUI_PaintContext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_MetricsRec_ {
    pub dpi: f32,
    pub density: f32,
    pub scaled_density: f32,
    pub scale: f32,
}
pub type LCUI_MetricsRec = LCUI_MetricsRec_;
impl LCUI_DensityLevel {
    pub const DENSITY_LEVEL_SMALL: LCUI_DensityLevel = LCUI_DensityLevel(0);
}
impl LCUI_DensityLevel {
    pub const DENSITY_LEVEL_NORMAL: LCUI_DensityLevel = LCUI_DensityLevel(1);
}
impl LCUI_DensityLevel {
    pub const DENSITY_LEVEL_LARGE: LCUI_DensityLevel = LCUI_DensityLevel(2);
}
impl LCUI_DensityLevel {
    pub const DENSITY_LEVEL_BIG: LCUI_DensityLevel = LCUI_DensityLevel(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_DensityLevel(pub ::std::os::raw::c_int);
extern "C" {
    #[doc = " 转换成单位为 px 的度量值"]
    pub fn LCUIMetrics_Compute(value: f32, type_: LCUI_StyleType) -> f32;
}
extern "C" {
    pub fn LCUIMetrics_ComputeStyle(style: LCUI_Style) -> f32;
}
extern "C" {
    #[doc = " 将矩形中的度量值的单位转换为 px"]
    pub fn LCUIMetrics_ComputeRectActual(dst: *mut LCUI_Rect, src: *const LCUI_RectF);
}
extern "C" {
    #[doc = " 转换成单位为 px 的实际度量值"]
    pub fn LCUIMetrics_ComputeActual(value: f32, type_: LCUI_StyleType) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 获取当前的全局缩放比例"]
    pub fn LCUIMetrics_GetScale() -> f32;
}
extern "C" {
    #[doc = " 设置密度"]
    pub fn LCUIMetrics_SetDensity(density: f32);
}
extern "C" {
    #[doc = " 设置缩放密度"]
    pub fn LCUIMetrics_SetScaledDensity(density: f32);
}
extern "C" {
    #[doc = " 设置密度等级"]
    pub fn LCUIMetrics_SetDensityLevel(level: LCUI_DensityLevel);
}
extern "C" {
    #[doc = " 设置缩放密度等级"]
    pub fn LCUIMetrics_SetScaledDensityLevel(level: LCUI_DensityLevel);
}
extern "C" {
    #[doc = " 设置 DPI"]
    pub fn LCUIMetrics_SetDpi(dpi: f32);
}
extern "C" {
    #[doc = " 设置全局缩放比例"]
    pub fn LCUIMetrics_SetScale(scale: f32);
}
extern "C" {
    pub fn LCUI_InitMetrics();
}
extern "C" {
    pub fn LCUI_GetMetrics() -> *const LCUI_MetricsRec;
}
extern "C" {
    pub fn LCUI_FreeMetrics();
}
pub type LCUI_Mutex = HANDLE;
pub type LCUI_Cond = HANDLE;
pub type LCUI_Thread = ::std::os::raw::c_uint;
extern "C" {
    pub fn LCUIMutex_Init(mutex: *mut LCUI_Mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIMutex_Destroy(mutex: *mut LCUI_Mutex);
}
extern "C" {
    pub fn LCUIMutex_TryLock(mutex: *mut LCUI_Mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIMutex_Lock(mutex: *mut LCUI_Mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIMutex_Unlock(mutex: *mut LCUI_Mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 初始化一个条件变量"]
    pub fn LCUICond_Init(cond: *mut LCUI_Cond) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 销毁一个条件变量"]
    pub fn LCUICond_Destroy(cond: *mut LCUI_Cond) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 阻塞当前线程，等待条件成立"]
    pub fn LCUICond_Wait(cond: *mut LCUI_Cond, mutex: *mut LCUI_Mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 计时阻塞当前线程，等待条件成立"]
    pub fn LCUICond_TimedWait(
        cond: *mut LCUI_Cond,
        mutex: *mut LCUI_Mutex,
        ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 唤醒一个阻塞等待条件成立的线程"]
    pub fn LCUICond_Signal(cond: *mut LCUI_Cond) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 唤醒所有阻塞等待条件成立的线程"]
    pub fn LCUICond_Broadcast(cond: *mut LCUI_Cond) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIThread_SelfID() -> LCUI_Thread;
}
extern "C" {
    pub fn LCUIThread_Create(
        tidp: *mut LCUI_Thread,
        start_rtn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIThread_Join(
        thread: LCUI_Thread,
        retval: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIThread_Cancel(thread: LCUI_Thread);
}
extern "C" {
    pub fn LCUIThread_Exit(retval: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_StyleSheetRec_ {
    pub sheet: LCUI_Style,
    pub length: ::std::os::raw::c_int,
}
pub type LCUI_StyleSheetRec = LCUI_StyleSheetRec_;
pub type LCUI_StyleSheet = *mut LCUI_StyleSheetRec_;
pub type LCUI_CachedStyleSheet = *const LCUI_StyleSheetRec;
pub type LCUI_StyleList = *mut LinkedList;
#[doc = " 选择器结点结构"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_SelectorNodeRec_ {
    #[doc = "< ID"]
    pub id: *mut ::std::os::raw::c_char,
    #[doc = "< 类型名称"]
    pub type_: *mut ::std::os::raw::c_char,
    #[doc = "< 样式类列表"]
    pub classes: *mut *mut ::std::os::raw::c_char,
    #[doc = "< 状态列表"]
    pub status: *mut *mut ::std::os::raw::c_char,
    #[doc = "< 全名，由 id、type、classes、status 组合而成"]
    pub fullname: *mut ::std::os::raw::c_char,
    #[doc = "< 权值"]
    pub rank: ::std::os::raw::c_int,
}
#[doc = " 选择器结点结构"]
pub type LCUI_SelectorNode = *mut LCUI_SelectorNodeRec_;
#[doc = " 选择器结构"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_SelectorRec_ {
    #[doc = "< 权值，决定优先级"]
    pub rank: ::std::os::raw::c_int,
    #[doc = "< 批次号"]
    pub batch_num: ::std::os::raw::c_int,
    #[doc = "< 选择器结点长度"]
    pub length: ::std::os::raw::c_int,
    #[doc = "< 哈希值"]
    pub hash: ::std::os::raw::c_uint,
    #[doc = "< 选择器结点列表"]
    pub nodes: *mut LCUI_SelectorNode,
}
#[doc = " 选择器结构"]
pub type LCUI_Selector = *mut LCUI_SelectorRec_;
extern "C" {
    pub fn LCUI_PutStyleSheet(
        selector: LCUI_Selector,
        in_ss: LCUI_StyleSheet,
        space: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 从指定组中查找样式表\n @param[in] group 组号\n @param[in] name 选择器结点名称，若为 NULL，则根据选择器结点生成名称\n @param[in] s 选择器\n @param[out] list 找到的样式表列表"]
    pub fn LCUI_FindStyleSheetFromGroup(
        group: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        s: LCUI_Selector,
        list: *mut LinkedList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_GetCachedStyleSheet(s: LCUI_Selector) -> LCUI_CachedStyleSheet;
}
extern "C" {
    pub fn LCUI_GetStyleSheet(s: LCUI_Selector, out_ss: LCUI_StyleSheet);
}
extern "C" {
    pub fn LCUI_PrintStyleSheetsBySelector(s: LCUI_Selector);
}
extern "C" {
    pub fn LCUI_SetStyleName(
        key: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_AddCSSPropertyName(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_AddStyleValue(
        key: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_GetStyleValue(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_GetStyleValueName(val: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn LCUI_GetStyleName(key: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn LCUI_GetStyleTotal() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_PrintStyleSheet(ss: LCUI_StyleSheet);
}
extern "C" {
    pub fn LCUI_PrintSelector(selector: LCUI_Selector);
}
extern "C" {
    pub fn LCUI_PrintCSSLibrary();
}
extern "C" {
    pub fn LCUI_InitCSSLibrary();
}
extern "C" {
    pub fn LCUI_FreeCSSLibrary();
}
#[doc = " 部件样式"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_WidgetStyle {
    pub visible: LCUI_BOOL,
    pub focusable: LCUI_BOOL,
    pub width_sizing: LCUI_SizingRule,
    pub height_sizing: LCUI_SizingRule,
    pub min_width: f32,
    pub min_height: f32,
    pub max_width: f32,
    pub max_height: f32,
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
    pub z_index: ::std::os::raw::c_int,
    pub opacity: f32,
    pub position: LCUI_StyleValue,
    pub display: LCUI_StyleValue,
    pub box_sizing: LCUI_StyleValue,
    pub vertical_align: LCUI_StyleValue,
    pub border: LCUI_BorderStyle,
    pub shadow: LCUI_BoxShadowStyle,
    pub background: LCUI_BackgroundStyle,
    pub flex: LCUI_FlexBoxLayoutStyle,
    pub pointer_events: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_WidgetActualStyleRec_ {
    pub x: f32,
    pub y: f32,
    pub canvas_box: LCUI_Rect,
    pub border_box: LCUI_Rect,
    pub padding_box: LCUI_Rect,
    pub content_box: LCUI_Rect,
    pub border: LCUI_Border,
    pub shadow: LCUI_BoxShadow,
    pub background: LCUI_Background,
}
pub type LCUI_WidgetActualStyle = *mut LCUI_WidgetActualStyleRec_;
#[doc = " See more: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_WidgetBoxModelRec_ {
    pub content: LCUI_RectF,
    pub padding: LCUI_RectF,
    pub border: LCUI_RectF,
    pub canvas: LCUI_RectF,
    pub outer: LCUI_RectF,
}
#[doc = " See more: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model"]
pub type LCUI_WidgetBoxModelRec = LCUI_WidgetBoxModelRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_WidgetTaskRec_ {
    #[doc = " Should update for self?"]
    pub for_self: LCUI_BOOL,
    #[doc = " Should update for children?"]
    pub for_children: LCUI_BOOL,
    #[doc = " Should skip the property sync of bound surface?"]
    pub skip_surface_props_sync: LCUI_BOOL,
    #[doc = " States of tasks"]
    pub states: [LCUI_BOOL; 19usize],
}
pub type LCUI_WidgetTaskRec = LCUI_WidgetTaskRec_;
impl LCUI_WidgetState {
    pub const LCUI_WSTATE_CREATED: LCUI_WidgetState = LCUI_WidgetState(0);
}
impl LCUI_WidgetState {
    pub const LCUI_WSTATE_UPDATED: LCUI_WidgetState = LCUI_WidgetState(1);
}
impl LCUI_WidgetState {
    pub const LCUI_WSTATE_LAYOUTED: LCUI_WidgetState = LCUI_WidgetState(2);
}
impl LCUI_WidgetState {
    pub const LCUI_WSTATE_READY: LCUI_WidgetState = LCUI_WidgetState(3);
}
impl LCUI_WidgetState {
    pub const LCUI_WSTATE_NORMAL: LCUI_WidgetState = LCUI_WidgetState(4);
}
impl LCUI_WidgetState {
    pub const LCUI_WSTATE_DELETED: LCUI_WidgetState = LCUI_WidgetState(5);
}
#[repr(transparent)]
#[doc = " 部件状态"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_WidgetState(pub ::std::os::raw::c_int);
pub type LCUI_Widget = *mut LCUI_WidgetRec_;
pub type LCUI_WidgetPrototype = *mut LCUI_WidgetPrototypeRec_;
pub type LCUI_WidgetPrototypeC = *const LCUI_WidgetPrototypeRec_;
pub type LCUI_WidgetFunction = ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Widget)>;
pub type LCUI_WidgetTaskHandler =
    ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Widget, arg2: ::std::os::raw::c_int)>;
pub type LCUI_WidgetSizeGetter = ::std::option::Option<
    unsafe extern "C" fn(arg1: LCUI_Widget, arg2: *mut f32, arg3: *mut f32, arg4: LCUI_LayoutRule),
>;
pub type LCUI_WidgetSizeSetter =
    ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Widget, arg2: f32, arg3: f32)>;
pub type LCUI_WidgetAttrSetter = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: LCUI_Widget,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ),
>;
pub type LCUI_WidgetTextSetter = ::std::option::Option<
    unsafe extern "C" fn(arg1: LCUI_Widget, arg2: *const ::std::os::raw::c_char),
>;
pub type LCUI_WidgetPropertyBinder = ::std::option::Option<
    unsafe extern "C" fn(arg1: LCUI_Widget, arg2: *const ::std::os::raw::c_char, arg3: LCUI_Object),
>;
pub type LCUI_WidgetPainter = ::std::option::Option<
    unsafe extern "C" fn(arg1: LCUI_Widget, arg2: LCUI_PaintContext, arg3: LCUI_WidgetActualStyle),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_WidgetPrototypeRec_ {
    pub name: *mut ::std::os::raw::c_char,
    pub init: LCUI_WidgetFunction,
    pub refresh: LCUI_WidgetFunction,
    pub destroy: LCUI_WidgetFunction,
    pub update: LCUI_WidgetFunction,
    pub runtask: LCUI_WidgetTaskHandler,
    pub setattr: LCUI_WidgetAttrSetter,
    pub settext: LCUI_WidgetTextSetter,
    pub bindprop: LCUI_WidgetPropertyBinder,
    pub autosize: LCUI_WidgetSizeGetter,
    pub resize: LCUI_WidgetSizeSetter,
    pub paint: LCUI_WidgetPainter,
    pub proto: LCUI_WidgetPrototype,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_WidgetDataEntryRec_ {
    pub data: *mut ::std::os::raw::c_void,
    pub proto: LCUI_WidgetPrototype,
}
pub type LCUI_WidgetDataEntryRec = LCUI_WidgetDataEntryRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_WidgetData_ {
    pub length: ::std::os::raw::c_uint,
    pub list: *mut LCUI_WidgetDataEntryRec,
}
pub type LCUI_WidgetData = LCUI_WidgetData_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_WidgetRulesRec_ {
    #[doc = " Suspend update if the current widget is not visible or is\n completely covered by other widgets"]
    pub only_on_visible: LCUI_BOOL,
    #[doc = " First update the children in the visible area\n If your widget has a lot of children and you want to see the\n children who are currently seeing the priority update, we recommend\n enabling this rule."]
    pub first_update_visible_children: LCUI_BOOL,
    #[doc = " Cache the stylesheets of children to improve the query speed of\n the stylesheet.\n If this rule is enabled, we recommend that you manually call\n Widget_GenerateHash() to generate a hash value for the children\n of the widget."]
    pub cache_children_style: LCUI_BOOL,
    #[doc = " Refresh the style of all child widgets if the status has changed"]
    pub ignore_status_change: LCUI_BOOL,
    #[doc = " Refresh the style of all child widgets if the classes has changed"]
    pub ignore_classes_change: LCUI_BOOL,
    #[doc = " Maximum number of children updated at each update\n values:\n -1 - Update all children at once\n 0  - Automatically calculates the appropriate maximum number\n N  - Custom maximum number"]
    pub max_update_children_count: ::std::os::raw::c_int,
    #[doc = " Limit the number of children rendered"]
    pub max_render_children_count: ::std::os::raw::c_uint,
    #[doc = " A callback function on update progress"]
    pub on_update_progress:
        ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Widget, arg2: usize)>,
}
pub type LCUI_WidgetRules = *mut LCUI_WidgetRulesRec_;
impl LCUI_InvalidAreaType_ {
    pub const LCUI_INVALID_AREA_TYPE_NONE: LCUI_InvalidAreaType_ = LCUI_InvalidAreaType_(0);
}
impl LCUI_InvalidAreaType_ {
    pub const LCUI_INVALID_AREA_TYPE_CUSTOM: LCUI_InvalidAreaType_ = LCUI_InvalidAreaType_(1);
}
impl LCUI_InvalidAreaType_ {
    pub const LCUI_INVALID_AREA_TYPE_PADDING_BOX: LCUI_InvalidAreaType_ = LCUI_InvalidAreaType_(2);
}
impl LCUI_InvalidAreaType_ {
    pub const LCUI_INVALID_AREA_TYPE_BORDER_BOX: LCUI_InvalidAreaType_ = LCUI_InvalidAreaType_(3);
}
impl LCUI_InvalidAreaType_ {
    pub const LCUI_INVALID_AREA_TYPE_CANVAS_BOX: LCUI_InvalidAreaType_ = LCUI_InvalidAreaType_(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_InvalidAreaType_(pub ::std::os::raw::c_int);
pub use self::LCUI_InvalidAreaType_ as LCUI_InvalidAreaType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_WidgetRec_ {
    pub hash: ::std::os::raw::c_uint,
    pub state: LCUI_WidgetState,
    pub id: *mut ::std::os::raw::c_char,
    pub type_: *mut ::std::os::raw::c_char,
    pub classes: strlist_t,
    pub status: strlist_t,
    pub title: *mut wchar_t,
    pub attributes: *mut Dict,
    pub disabled: LCUI_BOOL,
    pub event_blocked: LCUI_BOOL,
    #[doc = " Coordinates calculated by the layout system\n The position of the rectangular boxes is calculated based on it"]
    pub layout_x: f32,
    #[doc = " Coordinates calculated by the layout system\n The position of the rectangular boxes is calculated based on it"]
    pub layout_y: f32,
    #[doc = " Geometric parameters (readonly)\n Their values come from the box.border"]
    pub x: f32,
    #[doc = " Geometric parameters (readonly)\n Their values come from the box.border"]
    pub y: f32,
    #[doc = " Geometric parameters (readonly)\n Their values come from the box.border"]
    pub width: f32,
    #[doc = " Geometric parameters (readonly)\n Their values come from the box.border"]
    pub height: f32,
    #[doc = " A box’s “ideal” size in a given axis when given infinite available space.\n See more: https://drafts.csswg.org/css-sizing-3/#max-content"]
    pub max_content_width: f32,
    #[doc = " A box’s “ideal” size in a given axis when given infinite available space.\n See more: https://drafts.csswg.org/css-sizing-3/#max-content"]
    pub max_content_height: f32,
    pub padding: LCUI_Rect2F,
    pub margin: LCUI_Rect2F,
    pub box_: LCUI_WidgetBoxModelRec,
    pub style: LCUI_StyleSheet,
    pub custom_style: LCUI_StyleList,
    pub inherited_style: LCUI_CachedStyleSheet,
    pub computed_style: LCUI_WidgetStyle,
    #[doc = " Some data bound to the prototype"]
    pub data: LCUI_WidgetData,
    #[doc = " Prototype chain\n It is used to implement the inheritance of widgets,\n Just like prototype chain in JavaScript"]
    pub proto: LCUI_WidgetPrototypeC,
    #[doc = " Update task context"]
    pub task: LCUI_WidgetTaskRec,
    pub rules: LCUI_WidgetRules,
    pub trigger: LCUI_EventTrigger,
    #[doc = " Invalid area (Dirty Rectangle)"]
    pub invalid_area: LCUI_RectF,
    pub invalid_area_type: LCUI_InvalidAreaType,
    pub has_child_invalid_area: LCUI_BOOL,
    #[doc = " Parent widget"]
    pub parent: LCUI_Widget,
    #[doc = " List of child widgets"]
    pub children: LinkedList,
    #[doc = " List of child widgets in descending order by z-index"]
    pub children_show: LinkedList,
    #[doc = " Position in the parent->children\n this == LinkedList_Get(&this->parent->children, this.index)"]
    pub index: usize,
    #[doc = " Node in the parent->children\n &this->node == LinkedList_GetNode(&this->parent->children, this.index)"]
    pub node: LinkedListNode,
    #[doc = " Node in the parent->children_shoa"]
    pub node_show: LinkedListNode,
}
extern "C" {
    pub fn LCUIWidget_GetRoot() -> LCUI_Widget;
}
extern "C" {
    pub fn LCUIWidget_GetById(idstr: *const ::std::os::raw::c_char) -> LCUI_Widget;
}
extern "C" {
    #[doc = " Create a widget by prototype"]
    pub fn LCUIWidget_NewWithPrototype(proto: LCUI_WidgetPrototypeC) -> LCUI_Widget;
}
extern "C" {
    #[doc = " Create a widget by type name"]
    pub fn LCUIWidget_New(type_name: *const ::std::os::raw::c_char) -> LCUI_Widget;
}
extern "C" {
    pub fn LCUIWidget_ClearTrash() -> usize;
}
extern "C" {
    pub fn LCUIWidget_InitBase();
}
extern "C" {
    pub fn LCUIWidget_FreeRoot();
}
extern "C" {
    pub fn LCUIWidget_FreeBase();
}
extern "C" {
    pub fn LCUIWidget_InitIdLibrary();
}
extern "C" {
    pub fn LCUIWidget_FreeIdLibrary();
}
extern "C" {
    #[doc = " 初始化 LCUI 部件任务处理功能"]
    pub fn LCUIWidget_InitTasks();
}
extern "C" {
    #[doc = " 销毁（释放） LCUI 部件任务处理功能的相关资源"]
    pub fn LCUIWidget_FreeTasks();
}
extern "C" {
    #[doc = " 处理一次当前积累的部件任务"]
    pub fn LCUIWidget_Update() -> usize;
}
extern "C" {
    pub fn LCUIWidget_UpdateWithProfile(profile: LCUI_WidgetTasksProfile);
}
extern "C" {
    #[doc = " 刷新所有部件的样式"]
    pub fn LCUIWidget_RefreshStyle();
}
extern "C" {
    pub fn LCUIWidget_InitRenderer();
}
extern "C" {
    pub fn LCUIWidget_FreeRenderer();
}
extern "C" {
    pub fn LCUIWidget_InitPrototype();
}
extern "C" {
    pub fn LCUIWidget_FreePrototype();
}
extern "C" {
    pub fn LCUIWidget_GetPrototype(name: *const ::std::os::raw::c_char) -> LCUI_WidgetPrototype;
}
extern "C" {
    pub fn LCUIWidget_NewPrototype(
        name: *const ::std::os::raw::c_char,
        parent_name: *const ::std::os::raw::c_char,
    ) -> LCUI_WidgetPrototype;
}
pub type LCUI_WidgetMouseMotionEvent = LCUI_MouseMotionEvent;
pub type LCUI_WidgetMouseButtonEvent = LCUI_MouseButtonEvent;
pub type LCUI_WidgetMouseWheelEvent = LCUI_MouseWheelEvent;
pub type LCUI_WidgetTextInputEvent = LCUI_TextInputEvent;
#[doc = " The event structure to describe a user interaction with the keyboard"]
pub type LCUI_WidgetKeyboardEvent = LCUI_KeyboardEvent;
pub type LCUI_WidgetTouchEvent = LCUI_TouchEvent;
#[doc = " 面向部件级的事件内容结构"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LCUI_WidgetEventRec_ {
    #[doc = "< 事件类型标识号"]
    pub type_: u32,
    #[doc = "< 附加数据"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< 触发事件的部件"]
    pub target: LCUI_Widget,
    #[doc = "< 是否取消事件冒泡"]
    pub cancel_bubble: LCUI_BOOL,
    pub __bindgen_anon_1: LCUI_WidgetEventRec___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LCUI_WidgetEventRec___bindgen_ty_1 {
    pub motion: LCUI_WidgetMouseMotionEvent,
    pub button: LCUI_WidgetMouseButtonEvent,
    pub wheel: LCUI_WidgetMouseWheelEvent,
    pub key: LCUI_WidgetKeyboardEvent,
    pub touch: LCUI_WidgetTouchEvent,
    pub text: LCUI_WidgetTextInputEvent,
}
#[doc = " 面向部件级的事件内容结构"]
pub type LCUI_WidgetEvent = *mut LCUI_WidgetEventRec_;
extern "C" {
    #[doc = " 自动分配一个可用的事件标识号"]
    pub fn LCUIWidget_AllocEventId() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 设置与事件标识号对应的名称"]
    pub fn LCUIWidget_SetEventName(
        event_id: ::std::os::raw::c_int,
        event_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 获取与事件标识号对应的名称"]
    pub fn LCUIWidget_GetEventName(
        event_id: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " 获取与事件名称对应的标识号"]
    pub fn LCUIWidget_GetEventId(
        event_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_InitWidgetEvent(e: LCUI_WidgetEvent, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " 清除事件对象，通常在部件销毁时调用该函数，以避免部件销毁后还有事件发送给它"]
    pub fn LCUIWidget_ClearEventTarget(widget: LCUI_Widget);
}
extern "C" {
    #[doc = " get current focused widget"]
    pub fn LCUIWidget_GetFocus() -> LCUI_Widget;
}
extern "C" {
    #[doc = " 将一个部件设置为焦点"]
    pub fn LCUIWidget_SetFocus(widget: LCUI_Widget) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 初始化 LCUI 部件的事件系统"]
    pub fn LCUIWidget_InitEvent();
}
extern "C" {
    #[doc = " 销毁（释放） LCUI 部件的事件系统的相关资源"]
    pub fn LCUIWidget_FreeEvent();
}
extern "C" {
    #[doc = " 初始化"]
    pub fn LCUIWidget_InitStyle();
}
extern "C" {
    #[doc = " 销毁，释放资源"]
    pub fn LCUIWidget_FreeStyle();
}
extern "C" {
    pub fn LCUI_InitWidget();
}
extern "C" {
    pub fn LCUI_FreeWidget();
}
pub type LCUI_Surface = *mut ::std::os::raw::c_void;
#[doc = " surface 的操作方法集"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_DisplayDriverRec_ {
    pub name: [::std::os::raw::c_char; 256usize],
    pub getWidth: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub getHeight: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub create: ::std::option::Option<unsafe extern "C" fn() -> LCUI_Surface>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface)>,
    pub close: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface)>,
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: LCUI_Surface,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ),
    >,
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: LCUI_Surface,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ),
    >,
    pub show: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface)>,
    pub hide: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface)>,
    pub update: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface)>,
    pub present: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface)>,
    pub isReady: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface) -> LCUI_BOOL>,
    pub beginPaint: ::std::option::Option<
        unsafe extern "C" fn(arg1: LCUI_Surface, arg2: *mut LCUI_Rect) -> LCUI_PaintContext,
    >,
    pub endPaint:
        ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface, arg2: LCUI_PaintContext)>,
    pub setCaptionW:
        ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface, arg2: *const wchar_t)>,
    pub setRenderMode: ::std::option::Option<
        unsafe extern "C" fn(arg1: LCUI_Surface, arg2: ::std::os::raw::c_int),
    >,
    pub getHandle: ::std::option::Option<
        unsafe extern "C" fn(arg1: LCUI_Surface) -> *mut ::std::os::raw::c_void,
    >,
    pub getSurfaceWidth:
        ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface) -> ::std::os::raw::c_int>,
    pub getSurfaceHeight:
        ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface) -> ::std::os::raw::c_int>,
    pub setOpacity: ::std::option::Option<unsafe extern "C" fn(arg1: LCUI_Surface, arg2: f32)>,
    pub bindEvent: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: LCUI_EventFunc,
            arg3: *mut ::std::os::raw::c_void,
            arg4: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " surface 的操作方法集"]
pub type LCUI_DisplayDriver = *mut LCUI_DisplayDriverRec_;
extern "C" {
    pub fn LCUIDisplay_SetMode(mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 获取屏幕显示模式"]
    pub fn LCUIDisplay_GetMode() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 更新各种图形元素"]
    pub fn LCUIDisplay_Update();
}
extern "C" {
    #[doc = " 渲染内容"]
    pub fn LCUIDisplay_Render() -> usize;
}
extern "C" {
    #[doc = " 呈现渲染后的内容"]
    pub fn LCUIDisplay_Present();
}
extern "C" {
    pub fn LCUIDisplay_EnablePaintFlashing(enable: LCUI_BOOL);
}
extern "C" {
    #[doc = " 设置显示区域的尺寸，仅在窗口化、全屏模式下有效"]
    pub fn LCUIDisplay_SetSize(width: ::std::os::raw::c_int, height: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " 获取屏幕宽度"]
    pub fn LCUIDisplay_GetWidth() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 获取屏幕高度"]
    pub fn LCUIDisplay_GetHeight() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 添加无效区域"]
    pub fn LCUIDisplay_InvalidateArea(rect: *mut LCUI_Rect);
}
extern "C" {
    #[doc = " 获取当前部件所属的 surface"]
    pub fn LCUIDisplay_GetSurfaceOwner(w: LCUI_Widget) -> LCUI_Surface;
}
extern "C" {
    #[doc = " 根据 handle 获取 surface"]
    pub fn LCUIDisplay_GetSurfaceByHandle(handle: *mut ::std::os::raw::c_void) -> LCUI_Surface;
}
extern "C" {
    #[doc = " 绑定 surface 触发的事件"]
    pub fn LCUIDisplay_BindEvent(
        event_id: ::std::os::raw::c_int,
        func: LCUI_EventFunc,
        arg: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        destroy_data: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 初始化图形输出模块"]
    pub fn LCUI_InitDisplay(driver: LCUI_DisplayDriver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 停用图形输出模块"]
    pub fn LCUI_FreeDisplay() -> ::std::os::raw::c_int;
}
impl LCUI_FontStyle {
    pub const FONT_STYLE_NORMAL: LCUI_FontStyle = LCUI_FontStyle(0);
}
impl LCUI_FontStyle {
    pub const FONT_STYLE_ITALIC: LCUI_FontStyle = LCUI_FontStyle(1);
}
impl LCUI_FontStyle {
    pub const FONT_STYLE_OBLIQUE: LCUI_FontStyle = LCUI_FontStyle(2);
}
impl LCUI_FontStyle {
    pub const FONT_STYLE_TOTAL_NUM: LCUI_FontStyle = LCUI_FontStyle(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_FontStyle(pub ::std::os::raw::c_int);
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_NONE: LCUI_FontWeight = LCUI_FontWeight(0);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_THIN: LCUI_FontWeight = LCUI_FontWeight(100);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_EXTRA_LIGHT: LCUI_FontWeight = LCUI_FontWeight(200);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_LIGHT: LCUI_FontWeight = LCUI_FontWeight(300);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_NORMAL: LCUI_FontWeight = LCUI_FontWeight(400);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_MEDIUM: LCUI_FontWeight = LCUI_FontWeight(500);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_SEMI_BOLD: LCUI_FontWeight = LCUI_FontWeight(600);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_BOLD: LCUI_FontWeight = LCUI_FontWeight(700);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_EXTRA_BOLD: LCUI_FontWeight = LCUI_FontWeight(800);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_BLACK: LCUI_FontWeight = LCUI_FontWeight(900);
}
impl LCUI_FontWeight {
    pub const FONT_WEIGHT_TOTAL_NUM: LCUI_FontWeight = LCUI_FontWeight(9);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LCUI_FontWeight(pub ::std::os::raw::c_int);
#[doc = " 字体位图数据"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_FontBitmap_ {
    #[doc = "< 与顶边框的距离"]
    pub top: ::std::os::raw::c_int,
    #[doc = "< 与左边框的距离"]
    pub left: ::std::os::raw::c_int,
    #[doc = "< 位图宽度"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< 位图行数"]
    pub rows: ::std::os::raw::c_int,
    pub pitch: ::std::os::raw::c_int,
    #[doc = "< 字体位图数据"]
    pub buffer: *mut uchar_t,
    pub num_grays: ::std::os::raw::c_short,
    pub pixel_mode: ::std::os::raw::c_char,
    #[doc = "< XY轴的跨距"]
    pub advance: LCUI_Pos,
}
#[doc = " 字体位图数据"]
pub type LCUI_FontBitmap = LCUI_FontBitmap_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_FontRec_ {
    #[doc = "< 字体信息ID"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< 样式名称"]
    pub style_name: *mut ::std::os::raw::c_char,
    #[doc = "< 字族名称"]
    pub family_name: *mut ::std::os::raw::c_char,
    #[doc = "< 相关数据"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< 风格"]
    pub style: LCUI_FontStyle,
    #[doc = "< 粗细程度"]
    pub weight: LCUI_FontWeight,
    #[doc = "< 所属的字体引擎"]
    pub engine: *mut LCUI_FontEngine,
}
pub type LCUI_Font = *mut LCUI_FontRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_FontEngine {
    pub name: [::std::os::raw::c_char; 64usize],
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut LCUI_Font,
        ) -> ::std::os::raw::c_int,
    >,
    pub render: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut LCUI_FontBitmap,
            arg2: wchar_t,
            arg3: ::std::os::raw::c_int,
            arg4: LCUI_Font,
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
extern "C" {
    #[doc = " 根据字符串内容猜测字体粗细程度\n 文档：https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight"]
    pub fn LCUIFont_DetectWeight(str_: *const ::std::os::raw::c_char) -> LCUI_FontWeight;
}
extern "C" {
    #[doc = " 根据字符串内容猜测字体风格\n 文档：https://developer.mozilla.org/en-US/docs/Web/CSS/font-style"]
    pub fn LCUIFont_DetectStyle(str_: *const ::std::os::raw::c_char) -> LCUI_FontStyle;
}
extern "C" {
    pub fn LCUIFont_InitInCoreFont(engine: *mut LCUI_FontEngine) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIFont_ExitInCoreFont() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 载入字体位图"]
    pub fn LCUIFont_RenderBitmap(
        buff: *mut LCUI_FontBitmap,
        ch: wchar_t,
        font_id: ::std::os::raw::c_int,
        pixel_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 添加字体族，并返回该字族的ID"]
    pub fn LCUIFont_Add(font: LCUI_Font) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 获取字体的ID\n @param[in] family_name 字族名称\n @param[in] style 字体风格\n @param[in] weight 字体粗细程度，若为值 0，则默认为 FONT_WEIGHT_NORMAL"]
    pub fn LCUIFont_GetId(
        family_name: *const ::std::os::raw::c_char,
        style: LCUI_FontStyle,
        weight: LCUI_FontWeight,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 更新当前字体的粗细程度\n @param[in] font_ids 当前的字体 id 列表\n @params[in] weight 字体粗细程度\n @params[out] new_font_ids 更新字体粗细程度后的字体 id 列表"]
    pub fn LCUIFont_UpdateWeight(
        font_ids: *const ::std::os::raw::c_int,
        weight: LCUI_FontWeight,
        new_font_ids: *mut *mut ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " 更新当前字体的风格\n @param[in] font_ids 当前的字体 id 列表\n @params[in] style 字体风格\n @params[out] new_font_ids 更新字体粗细程度后的字体 id 列表"]
    pub fn LCUIFont_UpdateStyle(
        font_ids: *const ::std::os::raw::c_int,
        style: LCUI_FontStyle,
        new_font_ids: *mut *mut ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " 根据字族名称获取对应的字体 ID 列表\n @param[out] ids 输出的字体 ID 列表\n @param[in] style 风格\n @param[in] weight 字重，若为值 0，则默认为 FONT_WEIGHT_NORMAL\n @param[in] names 字族名称，多个名字用逗号隔开\n @return 获取到的字体 ID 的数量"]
    pub fn LCUIFont_GetIdByNames(
        font_ids: *mut *mut ::std::os::raw::c_int,
        style: LCUI_FontStyle,
        weight: LCUI_FontWeight,
        names: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " 获取指定字体ID的字体信息"]
    pub fn LCUIFont_GetById(id: ::std::os::raw::c_int) -> LCUI_Font;
}
extern "C" {
    #[doc = " 获取默认的字体ID"]
    pub fn LCUIFont_GetDefault() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 设定默认的字体"]
    pub fn LCUIFont_SetDefault(id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " 向字体缓存中添加字体位图\n @param[in] ch 字符码\n @param[in] font_id 使用的字体ID\n @param[in] size 字体大小（单位为像素）\n @param[out] bmp 要添加的字体位图\n @warning 此函数仅仅是将 bmp 复制进缓存中，并未重新分配新的空间储存位图数\n 据，因此，请勿在调用此函数后手动释放 bmp。"]
    pub fn LCUIFont_AddBitmap(
        ch: wchar_t,
        font_id: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        bmp: *const LCUI_FontBitmap,
    ) -> *mut LCUI_FontBitmap;
}
extern "C" {
    #[doc = " 从缓存中获取字体位图\n @param[in] ch 字符码\n @param[in] font_id 使用的字体ID\n @param[in] size 字体大小（单位为像素）\n @param[out] bmp 输出的字体位图的引用\n @warning 请勿释放 bmp，bmp 仅仅是引用缓存中的字体位图，并未建分配新\n 空间存储字体位图的拷贝。"]
    pub fn LCUIFont_GetBitmap(
        ch: wchar_t,
        font_id: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        bmp: *mut *const LCUI_FontBitmap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 载入字体至数据库中"]
    pub fn LCUIFont_LoadFile(filepath: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 初始化字体处理模块"]
    pub fn LCUI_InitFontLibrary();
}
extern "C" {
    #[doc = " 停用字体处理模块"]
    pub fn LCUI_FreeFontLibrary();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SETJMP_FLOAT128 {
    pub Part: [::std::os::raw::c_ulonglong; 2usize],
}
pub type SETJMP_FLOAT128 = _SETJMP_FLOAT128;
pub type _JBTYPE = SETJMP_FLOAT128;
pub type jmp_buf = [_JBTYPE; 16usize];
pub type LCUI_ImageProgressFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: f32)>;
pub type LCUI_ImageReadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> usize,
>;
pub type LCUI_ImageSkipFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_long),
>;
pub type LCUI_ImageFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_ImageHeaderRec_ {
    pub type_: ::std::os::raw::c_int,
    pub bit_depth: ::std::os::raw::c_int,
    pub color_type: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
}
pub type LCUI_ImageHeaderRec = LCUI_ImageHeaderRec_;
#[doc = " 图像读取器"]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_ImageReaderRec_ {
    #[doc = "< 自定义的输入流数据"]
    pub stream_data: *mut ::std::os::raw::c_void,
    #[doc = "< 是否有错误"]
    pub has_error: LCUI_BOOL,
    #[doc = "< 图像头部信息"]
    pub header: LCUI_ImageHeaderRec,
    #[doc = "< 在开始读取前调用的函数"]
    pub fn_begin: LCUI_ImageFunc,
    #[doc = "< 在结束读取时调用的函数"]
    pub fn_end: LCUI_ImageFunc,
    #[doc = "< 游标重置函数，用于重置当前读取位置到数据流的开头处"]
    pub fn_rewind: LCUI_ImageFunc,
    #[doc = "< 数据读取函数，用于从数据流中读取数据"]
    pub fn_read: LCUI_ImageReadFunc,
    #[doc = "< 游标移动函数，用于跳过一段数据"]
    pub fn_skip: LCUI_ImageSkipFunc,
    #[doc = "< 用于接收图像读取进度的函数"]
    pub fn_prog: LCUI_ImageProgressFunc,
    #[doc = "< 接收图像读取进度时的附加参数"]
    pub prog_arg: *mut ::std::os::raw::c_void,
    #[doc = "< 图片读取器类型"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< 私有数据"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< 私有数据的析构函数"]
    pub destructor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = "< 堆栈环境缓存的指针，用于 setjump()"]
    pub env: *mut jmp_buf,
    pub __bindgen_padding_0: u64,
    #[doc = "< 默认堆栈环境缓存"]
    pub env_src: jmp_buf,
}
#[doc = " 图像读取器"]
pub type LCUI_ImageReader = *mut LCUI_ImageReaderRec_;
extern "C" {
    #[doc = " 初始化适用于 PNG 图像的读取器"]
    pub fn LCUI_InitPNGReader(reader: LCUI_ImageReader) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 初始化适用于 JPEG 图像的读取器"]
    pub fn LCUI_InitJPEGReader(reader: LCUI_ImageReader) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 初始化适用于 BMP 图像的读取器"]
    pub fn LCUI_InitBMPReader(reader: LCUI_ImageReader) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_SetImageReaderForFile(reader: LCUI_ImageReader, fp: *mut FILE);
}
extern "C" {
    #[doc = " 创建图像读取器"]
    pub fn LCUI_InitImageReader(reader: LCUI_ImageReader) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 销毁图像读取器"]
    pub fn LCUI_DestroyImageReader(reader: LCUI_ImageReader);
}
extern "C" {
    pub fn LCUI_ReadPNGHeader(reader: LCUI_ImageReader) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ReadJPEGHeader(reader: LCUI_ImageReader) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ReadBMPHeader(reader: LCUI_ImageReader) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ReadImageHeader(reader: LCUI_ImageReader) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ReadPNG(reader: LCUI_ImageReader, graph: *mut LCUI_Graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ReadJPEG(reader: LCUI_ImageReader, graph: *mut LCUI_Graph)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ReadBMP(reader: LCUI_ImageReader, graph: *mut LCUI_Graph) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ReadImage(
        reader: LCUI_ImageReader,
        graph: *mut LCUI_Graph,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 将图像数据写入至png文件"]
    pub fn LCUI_WritePNGFile(
        file_name: *const ::std::os::raw::c_char,
        graph: *const LCUI_Graph,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 载入指定图片文件的图像数据"]
    pub fn LCUI_ReadImageFile(
        filepath: *const ::std::os::raw::c_char,
        out: *mut LCUI_Graph,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 从文件中获取图像尺寸"]
    pub fn LCUI_GetImageSize(
        filepath: *const ::std::os::raw::c_char,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_IMEHandlerRec_ {
    pub prockey: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> LCUI_BOOL,
    >,
    pub totext: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub open: ::std::option::Option<unsafe extern "C" fn() -> LCUI_BOOL>,
    pub close: ::std::option::Option<unsafe extern "C" fn() -> LCUI_BOOL>,
    pub setcaret: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int),
    >,
}
pub type LCUI_IMEHandler = *mut LCUI_IMEHandlerRec_;
extern "C" {
    #[doc = " 注册一个输入法"]
    pub fn LCUIIME_Register(
        ime_name: *const ::std::os::raw::c_char,
        handler: LCUI_IMEHandler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 选定输入法"]
    pub fn LCUIIME_Select(ime_id: ::std::os::raw::c_int) -> LCUI_BOOL;
}
extern "C" {
    pub fn LCUIIME_SelectByName(name: *const ::std::os::raw::c_char) -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 检测键值是否为字符键值"]
    pub fn LCUIIME_CheckCharKey(key: ::std::os::raw::c_int) -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 切换至下一个输入法"]
    pub fn LCUIIME_Switch();
}
extern "C" {
    #[doc = " 检测输入法是否要处理按键事件"]
    pub fn LCUIIME_ProcessKey(e: LCUI_SysEvent) -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 提交输入法输入的内容至目标"]
    pub fn LCUIIME_Commit(str_: *const wchar_t, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_InitIME();
}
extern "C" {
    pub fn LCUI_FreeIME();
}
extern "C" {
    pub fn LCUI_RegisterWin32IME() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIIME_SetCaret(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " 检测指定键值的按键是否处于按下状态"]
    pub fn LCUIKeyboard_IsHit(key_code: ::std::os::raw::c_int) -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 检测指定键值的按键是否按了两次\n @param key_code 要检测的按键的键值\n @param interval_time 该按键倒数第二次按下时的时间与当前时间的最大间隔"]
    pub fn LCUIKeyboard_IsDoubleHit(
        key_code: ::std::os::raw::c_int,
        interval_time: ::std::os::raw::c_int,
    ) -> LCUI_BOOL;
}
extern "C" {
    #[doc = " 添加已被按下的按键"]
    pub fn LCUIKeyboard_HitKey(key_code: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " 标记指定键值的按键已释放"]
    pub fn LCUIKeyboard_ReleaseKey(key_code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn LCUI_InitKeyboard();
}
extern "C" {
    pub fn LCUI_FreeKeyboard();
}
extern "C" {
    pub fn LCUIPainter_Begin(canvas: *mut LCUI_Graph, rect: *mut LCUI_Rect) -> LCUI_PaintContext;
}
extern "C" {
    pub fn LCUIPainter_End(paint: LCUI_PaintContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LCUI_SettingsRec_ {
    pub frame_rate_cap: ::std::os::raw::c_int,
    pub parallel_rendering_threads: ::std::os::raw::c_int,
    pub record_profile: LCUI_BOOL,
    pub fps_meter: LCUI_BOOL,
    pub paint_flashing: LCUI_BOOL,
}
pub type LCUI_Settings = *mut LCUI_SettingsRec_;
extern "C" {
    pub fn LCUI_ApplySettings(settings: LCUI_Settings);
}
extern "C" {
    pub fn LCUI_ResetSettings();
}
pub type TimerCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " 设置定时器\n 定时器的作用是让一个任务在经过指定时间后才执行\n @param n_ms\n\t等待的时间，单位为毫秒\n @param callback_\n\t用于响应定时器的回调函数\n @param reuse\n\t指示该定时器是否重复使用，如果要用于循环定时处理某些任\n\t务，可将它置为 TRUE，否则置于 FALSE。\n @return\n\t该定时器的标识符"]
    pub fn LCUITimer_Set(
        n_ms: ::std::os::raw::c_long,
        callback: TimerCallback,
        arg: *mut ::std::os::raw::c_void,
        reuse: LCUI_BOOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " repeatedly calls a function, with a fixed time delay between each call."]
    pub fn LCUI_SetTimeout(
        n_ms: ::std::os::raw::c_long,
        callback: TimerCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a timer which execute a function once after the timer expires."]
    pub fn LCUI_SetInterval(
        n_ms: ::std::os::raw::c_long,
        callback: TimerCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 释放定时器\n 当不需要定时器时，可以使用该函数释放定时器占用的资源，并移除程序任务队列\n 中还未处理的定时器任务\n @param timer_id\n\t需要释放的定时器的标识符\n @return\n\t正常返回0，指定ID的定时器不存在则返回-1."]
    pub fn LCUITimer_Free(timer_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 暂停定时器的倒计时\n 一般用于往复定时的定时器\n @param timer_id\n\t目标定时器的标识符\n @return\n\t正常返回0，指定ID的定时器不存在则返回-1."]
    pub fn LCUITimer_Pause(timer_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 继续定时器的倒计时\n @param timer_id\n\t目标定时器的标识符\n @return\n\t正常返回0，指定ID的定时器不存在则返回-1."]
    pub fn LCUITimer_Continue(timer_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 重设定时器的等待时间\n @param timer_id\n\t需要释放的定时器的标识符\n @param n_ms\n\t等待的时间，单位为毫秒\n @return\n\t正常返回0，指定ID的定时器不存在则返回-1."]
    pub fn LCUITimer_Reset(
        timer_id: ::std::os::raw::c_int,
        n_ms: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUI_ProcessTimers() -> usize;
}
extern "C" {
    pub fn LCUI_InitTimer();
}
extern "C" {
    pub fn LCUI_FreeTimer();
}
pub type LCUI_Worker = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn LCUIWorker_New() -> LCUI_Worker;
}
extern "C" {
    pub fn LCUIWorker_PostTask(worker: LCUI_Worker, task: LCUI_Task);
}
extern "C" {
    pub fn LCUIWorker_GetTask(worker: LCUI_Worker) -> LCUI_Task;
}
extern "C" {
    pub fn LCUIWorker_RunTask(worker: LCUI_Worker) -> LCUI_BOOL;
}
extern "C" {
    pub fn LCUIWorker_RunAsync(worker: LCUI_Worker) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCUIWorker_Destroy(worker: LCUI_Worker);
}
